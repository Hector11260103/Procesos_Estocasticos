# -*- coding: utf-8 -*-
"""Paper Estocastica Arima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pnsli18wZZd5rlluLhfFdjIFZVY9FvWb
"""

from google.colab import files

# Subir el archivo desde la computadora
uploaded = files.upload()

!pip install pmdarima

# 📌 Importar Librerías Necesarias
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima  # Para encontrar los mejores parámetros automáticamente

# 📌 1. Cargar el Dataset
file_path = "dataset_transformado.csv"  # Ajusta el nombre del archivo
df = pd.read_csv(file_path)

# 📌 2. Verificar si la columna 'Fecha' existe y convertirla a formato datetime
if 'Fecha' not in df.columns:
    raise ValueError("La columna 'Fecha' no está en el dataset. Verifica el archivo CSV.")

df['Fecha'] = pd.to_datetime(df['Fecha'], errors='coerce')  # Convertir a datetime
df = df.dropna(subset=['Fecha'])  # Eliminar filas con fechas inválidas
df.set_index('Fecha', inplace=True)  # Usar Fecha como índice

# 📌 3. Convertir 'Valor' a numérico y eliminar valores no numéricos
df['Valor'] = pd.to_numeric(df['Valor'], errors='coerce')
df = df.dropna(subset=['Valor'])  # Eliminar filas con valores nulos en 'Valor'

# 📌 4. Visualizar la Serie Temporal Original
plt.figure(figsize=(10, 5))
plt.plot(df.index, df['Valor'], label="Serie Original", color="blue")
plt.title("📈 Serie Temporal Original")
plt.xlabel("Fecha")
plt.ylabel("Valor")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.show()

# 📌 5. Prueba de Estacionariedad (ADF)
print("\n🔍 Prueba de Estacionariedad ADF:")
adf_test = adfuller(df['Valor'])
print(f"   📊 Estadística ADF: {adf_test[0]}")
print(f"   📊 P-valor: {adf_test[1]}")
print(f"   📊 Valores Críticos: {adf_test[4]}")
if adf_test[1] > 0.05:
    print("   ❌ La serie NO es estacionaria. Aplicando diferenciación...")
    df['Valor_Diff'] = df['Valor'].diff().dropna()
    adf_test_diff = adfuller(df['Valor_Diff'].dropna())
    print(f"   📊 P-valor después de diferenciación: {adf_test_diff[1]}")
else:
    print("   ✅ La serie es estacionaria.")

# 📌 6. Determinar los Mejores Parámetros ARIMA (p,d,q) Automáticamente
print("\n🔍 Buscando los mejores parámetros ARIMA...")
modelo_auto = auto_arima(df['Valor'].dropna(), seasonal=False, stepwise=True, trace=True)
p, d, q = modelo_auto.order  # Extraer los mejores valores de p, d, q
print(f"   📌 Parámetros óptimos encontrados: ARIMA({p},{d},{q})")

# 📌 7. Ajustar Modelo ARIMA con los Parámetros Óptimos
modelo_arima = ARIMA(df['Valor'], order=(p, d, q))
resultado_arima = modelo_arima.fit()

# 📌 8. Predicción con ARIMA
horizonte = 10  # Número de periodos futuros
prediccion = resultado_arima.forecast(steps=horizonte)

# 📌 Crear Fechas Futuras para la Predicción
ult_fecha = df.index[-1]
fechas_futuras = [ult_fecha + pd.DateOffset(months=i) for i in range(1, horizonte+1)]

# 📌 9. Visualizar la Predicción ARIMA
plt.figure(figsize=(10, 5))
plt.plot(df.index, df['Valor'], label="Serie Original", color="blue")
plt.plot(fechas_futuras, prediccion, label="🔴 Predicción ARIMA", linestyle='dashed', color="red")
plt.title("📈 Predicción ARIMA de la Serie Temporal")
plt.xlabel("Fecha")
plt.ylabel("Valor")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.show()

# 📌 10. Mostrar el Resumen del Modelo
print("\n📈 Resumen del modelo ARIMA:")
print(resultado_arima.summary())

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima  # Encuentra automáticamente el mejor modelo
from statsmodels.tsa.stattools import adfuller

# 📌 1. Cargar el dataset
file_path = "dataset_transformado.csv"
df = pd.read_csv(file_path, parse_dates=['Fecha'], index_col='Fecha')

# 📌 2. Comprobar estacionariedad
adf_test = adfuller(df['Valor'])
print(f"P-valor ADF: {adf_test[1]}")
if adf_test[1] > 0.05:
    df['Valor'] = df['Valor'].diff().dropna()

# 📌 3. Encontrar el mejor modelo ARIMA
modelo_auto = auto_arima(df['Valor'], seasonal=False, stepwise=True, trace=True)
p, d, q = modelo_auto.order

# 📌 4. Ajustar el modelo ARIMA con los mejores parámetros
modelo_arima = ARIMA(df['Valor'], order=(p, d, q))
resultado_arima = modelo_arima.fit()
print(resultado_arima.summary())

# 📌 5. Predicción a futuro
predicciones = resultado_arima.forecast(steps=10)

# 📌 6. Graficar resultados
plt.figure(figsize=(10,5))
plt.plot(df.index, df['Valor'], label="Serie Original", color="blue")
plt.plot(pd.date_range(df.index[-1], periods=10, freq='M'), predicciones, 'r--', label="Predicción ARIMA")
plt.title("Modelo ARIMA - Predicción")
plt.xlabel("Fecha")
plt.ylabel("Valor")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima
from statsmodels.tsa.stattools import adfuller, acf, pacf

# 📌 1. Cargar el dataset
file_path = "dataset_transformado.csv"
df = pd.read_csv(file_path, parse_dates=['Fecha'], index_col='Fecha')

# 📌 2. Prueba de estacionariedad (ADF)
adf_test = adfuller(df['Valor'])
print(f"📊 P-valor ADF: {adf_test[1]}")
if adf_test[1] > 0.05:
    print("❌ La serie NO es estacionaria. Aplicando diferenciación...")
    df['Valor'] = df['Valor'].diff().dropna()
    print("✅ Serie diferenciada.")

# 📌 3. Encontrar el mejor modelo ARIMA
modelo_auto = auto_arima(df['Valor'].dropna(), seasonal=False, stepwise=True, trace=True)
p, d, q = modelo_auto.order
print(f"🔍 Mejor modelo ARIMA sugerido: ARIMA({p},{d},{q})")

# 📌 4. Ajustar el modelo ARIMA
modelo_arima = ARIMA(df['Valor'].dropna(), order=(p, d, q))
resultado_arima = modelo_arima.fit()
print("\n📈 Resumen del modelo:")
print(resultado_arima.summary())

# 📌 5. Predicción a futuro (10 períodos)
predicciones = resultado_arima.forecast(steps=10)

# 📌 6. Graficar serie original y predicción
plt.figure(figsize=(10,5))
plt.plot(df.index, df['Valor'], label="📈 Serie Original", color="blue")
plt.plot(pd.date_range(df.index[-1], periods=10, freq='M'), predicciones, 'r--', label="🔴 Predicción ARIMA")
plt.title("📊 Modelo ARIMA - Predicción")
plt.xlabel("Fecha")
plt.ylabel("Valor")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.show()

# 📌 7. Diagnóstico de residuos
residuos = resultado_arima.resid
plt.figure(figsize=(10,4))
sns.histplot(residuos, kde=True, color="blue")
plt.title("Distribución de los residuos")
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima
from statsmodels.tsa.stattools import adfuller, acf, pacf

# 📌 1. Cargar el dataset
file_path = "dataset_transformado.csv"
df = pd.read_csv(file_path, parse_dates=['Fecha'], index_col='Fecha')

# 📌 2. Prueba de estacionariedad (ADF)
adf_test = adfuller(df['Valor'])
print(f"📊 P-valor ADF: {adf_test[1]}")
if adf_test[1] > 0.05:
    print("❌ La serie NO es estacionaria. Aplicando transformación logarítmica...")
    df['Valor'] = np.log1p(df['Valor'])  # Log-transform para estabilizar la varianza
    df['Valor'] = df['Valor'].diff().dropna()  # Diferenciación para estacionariedad
    print("✅ Serie transformada y diferenciada.")

# 📌 3. Encontrar el mejor modelo ARIMA
modelo_auto = auto_arima(df['Valor'].dropna(), seasonal=False, stepwise=True, trace=True)
p, d, q = modelo_auto.order
print(f"🔍 Mejor modelo ARIMA sugerido: ARIMA({p},{d},{q})")

# 📌 4. Ajustar el modelo ARIMA
modelo_arima = ARIMA(df['Valor'].dropna(), order=(p, d, q))
resultado_arima = modelo_arima.fit()
print("\n📈 Resumen del modelo:")
print(resultado_arima.summary())

# 📌 5. Predicción a futuro (10 períodos)
predicciones = resultado_arima.forecast(steps=10)

# 📌 6. Graficar serie original y predicción
plt.figure(figsize=(10,5))
plt.plot(df.index, df['Valor'], label="📈 Serie Original", color="blue")
plt.plot(pd.date_range(df.index[-1], periods=10, freq='M'), predicciones, 'r--', label="🔴 Predicción ARIMA")
plt.title("📊 Modelo ARIMA - Predicción")
plt.xlabel("Fecha")
plt.ylabel("Valor")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.show()

# 📌 7. Diagnóstico de residuos
residuos = resultado_arima.resid
plt.figure(figsize=(10,4))
sns.histplot(residuos, kde=True, color="blue")
plt.title("Distribución de los residuos")
plt.show()

df['Valor_Log'] = np.log1p(df['Valor'])  # Transformación logarítmica

# 📌 Revisar cuántos valores NaN hay en 'Valor_Log'
print(f"Valores NaN en 'Valor_Log': {df['Valor_Log'].isna().sum()}")

# 📌 Rellenar los valores NaN con interpolación o media
df['Valor_Log'] = df['Valor_Log'].interpolate(method='linear')  # Interpolación lineal
df.fillna({'Valor_Log': df['Valor_Log'].mean()}, inplace=True)  # O usar la media si persisten NaN

# 📌 Confirmar que ya no hay NaN
print(f"Valores NaN después de limpieza: {df['Valor_Log'].isna().sum()}")

print(f"Valores Infinitos: {np.isinf(df['Valor_Log']).sum()}")
print(f"Valores Muy Altos: {df['Valor_Log'].max()}")
print(f"Valores Muy Bajos: {df['Valor_Log'].min()}")

print(df[df['Valor'] <= 0])  # Mostrar filas con valores <= 0

df['Valor_Ajustado'] = df['Valor'] - df['Valor'].min() + 1  # Desplazar todos los valores a positivos
df['Valor_Log'] = np.log1p(df['Valor_Ajustado'])  # Aplicar logaritmo seguro

print(f"Valores Infinitos después de limpieza: {np.isinf(df['Valor_Log']).sum()}")
print(f"Valores NaN después de limpieza: {df['Valor_Log'].isna().sum()}")

from pmdarima import auto_arima

modelo_auto = auto_arima(df['Valor_Log'], seasonal=False, stepwise=True, trace=True)
print(modelo_auto.summary())

from statsmodels.tsa.arima.model import ARIMA

modelo_arima_opt = ARIMA(df['Valor_Log'], order=(3, 0, 2))
resultado_opt = modelo_arima_opt.fit()
print(resultado_opt.summary())

import seaborn as sns
import matplotlib.pyplot as plt

residuos = resultado_opt.resid

plt.figure(figsize=(10,4))
sns.histplot(residuos, kde=True, color="blue")
plt.title("Distribución de los residuos")
plt.show()

from statsmodels.tsa.arima.model import ARIMA

modelo_alternativo = ARIMA(df['Valor_Log'], order=(1, 0, 3))  # Prueba con menor AR
resultado_alt = modelo_alternativo.fit()
print(resultado_alt.summary())

from statsmodels.tsa.arima.model import ARIMA

modelo_alternativo = ARIMA(df['Valor_Log'], order=(1, 0, 2))  # Prueba con menor AR
resultado_alt = modelo_alternativo.fit()
print(resultado_alt.summary())

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# 📌 Cargar los datos (asegúrate de que df['Valor_Log'] ya está preparado)
# df = pd.read_csv("data.csv")  # Si es necesario cargar desde un archivo

# 📌 Ajustar el modelo ARIMA(1,0,2)
modelo_arima = ARIMA(df['Valor_Log'], order=(1, 0, 2))
resultado_arima = modelo_arima.fit()
print(resultado_arima.summary())

# 📌 Predicciones del modelo
predicciones = resultado_arima.predict(start=0, end=len(df)-1)

# 📌 Gráfico de la serie temporal y predicciones
plt.figure(figsize=(12,5))
plt.plot(df.index, df['Valor_Log'], label="Serie Original (Log)", color="blue")
plt.plot(df.index, predicciones, label="Predicción ARIMA(1,0,2)", linestyle="dashed", color="red")
plt.title("Serie Temporal vs. Predicción ARIMA(1,0,2)")
plt.xlabel("Fecha")
plt.ylabel("Valor Log")
plt.legend()
plt.grid()
plt.show()

# 📌 Gráfico de residuos
residuos = resultado_arima.resid
plt.figure(figsize=(12,5))
plt.plot(df.index, residuos, color='purple')
plt.axhline(y=0, linestyle='dashed', color='black')
plt.title("Residuos del Modelo ARIMA(1,0,2)")
plt.xlabel("Fecha")
plt.ylabel("Residuo")
plt.grid()
plt.show()

# 📌 Histograma de residuos con KDE
plt.figure(figsize=(12,5))
sns.histplot(residuos, bins=50, kde=True, color='blue')
plt.title("Distribución de los Residuos")
plt.xlabel("Valor del Residuo")
plt.ylabel("Frecuencia")
plt.grid()
plt.show()

# 📌 ACF y PACF de los residuos
fig, ax = plt.subplots(1, 2, figsize=(15,5))
plot_acf(residuos, ax=ax[0], lags=30)
ax[0].set_title("Autocorrelación (ACF) de los Residuos")
plot_pacf(residuos, ax=ax[1], lags=30)
ax[1].set_title("Autocorrelación Parcial (PACF) de los Residuos")
plt.show()